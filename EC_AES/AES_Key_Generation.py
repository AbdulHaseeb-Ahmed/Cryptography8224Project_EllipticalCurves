import numpy as np
vhex = np.vectorize(hex)

s_box = np.array([
    [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76],
    [0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0],
    [0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15],
    [0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75],
    [0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84],
    [0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF],
    [0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8],
    [0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2],
    [0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73],
    [0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB],
    [0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79],
    [0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08],
    [0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A],
    [0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E],
    [0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF],
    [0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]
])

r_con = np.array([
    [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
])


def key_state(input_list):
    key_state = np.zeros([4, 4], dtype="int")
    index = 0
    for row in range(0, 4):
        for col in range(0, 4):
            key_state[col][row] = input_list[index]
            index = index + 1
    return key_state


def rotword(key_state):
    key_rotword = np.zeros([4, 1], dtype="int")
    key_rotword[0] = key_state[1][3]
    key_rotword[1] = key_state[2][3]
    key_rotword[2] = key_state[3][3]
    key_rotword[3] = key_state[0][3]
    return key_rotword


def sub_byte_func(key_rotword):
    sub_byte_pre = vhex(key_rotword)
    sub_byte = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        n = sub_byte_pre[i][0]
        if(len(n) == 3):
            row = 0
            col = int(n[2], 16)
        else:
            row = int(n[2], 16)
            col = int(n[3], 16)
        sub_byte[i][0] = int(s_box[row][col])
    return sub_byte


def round_constant_func(round):
    round_constant = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        round_constant[i][0] = r_con[i, round]
    return round_constant


def g_func(sub_byte, round_constant):
    g_function = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        g_function[i][0] = sub_byte[i][0] ^ round_constant[i][0]
    return g_function


def new_key(g_function, key_state):
    w4 = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        w4[i][0] = key_state[i][0] ^ g_function[i][0]

    w5 = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        w5[i][0] = w4[i][0] ^ key_state[i][1]

    w6 = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        w6[i][0] = w5[i][0] ^ key_state[i][2]

    w7 = np.zeros([4, 1], dtype="int")
    for i in range(0, 4):
        w7[i][0] = w6[i][0] ^ key_state[i][3]

    w4_post = np.reshape(w4, (1, 4))
    w5_post = np.reshape(w5, (1, 4))
    w6_post = np.reshape(w6, (1, 4))
    w7_post = np.reshape(w7, (1, 4))
    roundkey_dec = np.concatenate((w4_post, w5_post, w6_post, w7_post), axis=1)

    roundkey_dec_final = []
    roundkey_hex = []
    for i in range(0, 16):
        roundkey_dec_final.append(int(roundkey_dec[0][i]))
        roundkey_hex.append(hex(roundkey_dec[0][i])[2:4].capitalize())

    return roundkey_dec_final, roundkey_hex

def key_sch(key_in):
    keys_hex = np.empty([11,16], dtype="S2")
    keys_dec = np.empty([11, 16], dtype="int")

    hexes = []
    for i in range(0, len(key_in)):
        hexes.append(format(ord(key_in[i]), "x").upper())

    keys_hex[0] = hexes
    keys_dec[0] = [int(x.decode('utf-8'), 16) for x in keys_hex[0]]

    new_keys_hex = np.empty([11, 16], dtype=object)
    for i in range(0, len(keys_hex[0])):
        if len(keys_hex[0][i].decode('utf-8').upper()) == 2:
            new_keys_hex[0][i] = (keys_hex[0][i].decode('utf-8').upper())
        else:
            new_keys_hex[0][i] = "0" + (keys_hex[0][i].decode('utf-8').upper())

    key_state_dec = key_state(keys_dec[0])  # reorders the input list into a matrix

    for roundd in range(0, 10):
        key_rotword = rotword(key_state_dec)  # shuffles the last column of the key_state
        sub_byte = sub_byte_func(key_rotword)
        round_constant = round_constant_func(roundd)
        g_function = g_func(sub_byte, round_constant)
        key = new_key(g_function, key_state_dec)
        keys_hex[roundd + 1] = key[1]
        for i in range(0, len(key[1])):
            if len((key[1][i].upper())) == 2:
                new_keys_hex[roundd + 1][i] = (key[1][i].upper())
            else:
                new_keys_hex[roundd + 1][i] = "0" + (key[1][i].upper())
        keys_dec[roundd + 1] = key[0]
        if (roundd < 9):
            key_state_dec = key_state(key[0])

    return new_keys_hex

